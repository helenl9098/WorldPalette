global proc reorderPriority()
{
    global string $scrollPriority;
    global int $priorityOrder[]; // this keeps track of the updates
    // Total number of items
    int $numItems = `textScrollList -q -ni $scrollPriority`;
    // Get selected item index
    int $clickedItem[] = `textScrollList -q -sii $scrollPriority`;
    // Get all items
    string $allItems[] = `textScrollList -q -ai $scrollPriority`;
    // If the first item is already the clicked item, do nothing
    if ($allItems[0] == $allItems[$clickedItem[0] - 1]) {
        return;
    } else {
        // Bring this item to the top
        textScrollList -e -ap 1 ($allItems[$clickedItem[0] - 1] + "") $scrollPriority;
        // Remove the item at the old position
        textScrollList -e -rii ($clickedItem[0] + 1) $scrollPriority;
        
        // Update the priority order array
        // Shift elements until you get to the moved item's index
        int $replaced = $priorityOrder[0];
        $priorityOrder[0] = $priorityOrder[$clickedItem[0] - 1];
        for ($i = 1; $i < $clickedItem[0]; $i++) {
            int $replaced2 = $priorityOrder[$i];
            $priorityOrder[$i] = $replaced;
            $replaced = $replaced2;
        }
    }
}

global proc updatePriority()
{
    // IF WE ADD MORE CATEGORIES, WE MUST UPDATE THIS FUNCTION!!!
    global int $priorityOrder[];
    // Send updated order to C++
    WorldPalette -po $priorityOrder[0] $priorityOrder[1] $priorityOrder[2] $priorityOrder[3];
}

global proc fillPriority()
{
    // IF WE ADD MORE CATEGORIES, WE MUST UPDATE THIS FUNCTION!!!
    global string $scrollPriority;
    global int $priorityOrder[];
    for ($i = 0; $i < 4; $i++) {
        switch($priorityOrder[$i]) {
            case 0:
                textScrollList -e -a "GRASS" $scrollPriority;
                break;
            case 1:
                textScrollList -e -a "ROCK" $scrollPriority;
                break;
            case 2:
                textScrollList -e -a "SHRUB" $scrollPriority;
                break;
            case 3:
                textScrollList -e -a "TREE" $scrollPriority;
                break;
            default:
                break;
        }
    }
}

global proc deleteCurrentSelectRegion()
{
    global int $selectionType;
    global string $selectionRegion[];

    // Delete current selection region (if there is one)
    if ($selectionType) {
        select -r $selectionRegion[0];
        delete;
        $selectionType = 0;

        // We must also reset the move GUI tools related to this

        // Selection region sliders
        global string $moveXSlider;
        global string $moveZSlider;
        global string $widthSlider;
        global string $heightSlider;
        // Reset slider values
        floatSliderGrp -e -v 0 $moveXSlider;
        floatSliderGrp -e -v 0 $moveZSlider;
        floatSliderGrp -e -v 1 $widthSlider;
        floatSliderGrp -e -v 1 $heightSlider;
        // Disable move sliders
        floatSliderGrp -e -en false $moveXSlider;
        floatSliderGrp -e -en false $moveZSlider;
        // Disable width/height sliders
        floatSliderGrp -e -en false $widthSlider;
        floatSliderGrp -e -en false $heightSlider;

        // Editing tools
        global int $isMoveDistributionActive;
        global int $isResizeDistributionActive;
        global string $moveButton;
        global string $resizeButton;
        $isMoveDistributionActive = false;
        $isResizeDistributionActive = false;
        iconTextButton -e -l "Start Moving Distribution" $moveButton;
        iconTextButton -e -l "Start Resizing Distribution" $resizeButton;

        // Undo tools
        global int $canUndoMove;
        global string $undoMoveButton;
        global int $canUndoResize;
        global string $undoResizeButton;
        $canUndoMove = false;
        $canUndoResize = false;
        iconTextButton -e -en false $undoMoveButton;
        iconTextButton -e -en false $undoResizeButton;
    }
}

global proc makePlanarSelectRegion()
{
    global string $selectionMat;
    global string $selectionRegion[];
    global int $selectionType;
    global string $selectionLayer;
    global int $isTerrainLoaded;

    // Selection region sliders
    global string $moveXSlider;
    global string $moveZSlider;
    global string $widthSlider;
    global string $heightSlider;

    int $res = 10; // plane resolution
    if ($selectionType != 1) {
        // Create a 2-D selection bound from a plane
        $selectionRegion = `polyPlane -name "selectionRegion" -sw $res -sh $res`;
        scale -r 2 2 2;
        
        // Assign selection material to plane
        hyperShade -assign $selectionMat;
        $selectionType = 1;
        // Add the plane to selectionLayer
        layerEditorAddObjects $selectionLayer;
        
        // Map region vertices to terrain height (if there is terrain)
        if ($isTerrainLoaded) {
            WorldPalette -msr true;
        }
        select -cl  ; // deselect
        // Enable move sliders
        floatSliderGrp -e -en true $moveXSlider;
        floatSliderGrp -e -en true $moveZSlider;
        // Enable width & height sliders
        floatSliderGrp -e -en true $widthSlider;
        floatSliderGrp -e -en true $heightSlider;
    }
}

global proc makeRadialSelectRegion()
{
    global string $selectionMat;
    global string $selectionRegion[];
    global int $selectionType;
    global string $selectionLayer;
    global int $isTerrainLoaded;

    // Selection region sliders
    global string $moveXSlider;
    global string $moveZSlider;
    global string $widthSlider;

    int $res = 20; // disk resolution
    if ($selectionType != 2) {
        // Create a 2-D selection bound from a disc
        $selectionRegion = `polyCylinder -name "selectionRegion" -height 0.010 -sx $res -sz $res`;
        
        // Assign selection material to disc
        hyperShade -assign $selectionMat;
        $selectionType = 2;
        // Add the disc to selectionLayer
        layerEditorAddObjects $selectionLayer;
        
        // Map region vertices to terrain height (if there is terrain)
        if ($isTerrainLoaded) {
            WorldPalette -msr true;
        }
        select -cl  ; // deselect
        // Enable move sliders
        floatSliderGrp -e -en true $moveXSlider;
        floatSliderGrp -e -en true $moveZSlider;
        // Enable width slider
        floatSliderGrp -e -en true $widthSlider;
    }
}

global proc focusOnCurrentSelection()
{
    global string $selectionRegion[];
    global int $selectionType;
    if ($selectionType) {
        select -r $selectionRegion[0];
        viewFit -f 0.;
        select -cl  ; // deselect
    } else {
        confirmDialog -t "No Region Selected" -m "You must first create a selection region on canvas." -b "OK" -icn "warning";
    }
}

global proc changeMoveStatus()
{
    global int $selectionType;

    global int $isMoveDistributionActive;
    global string $moveButton;

    // Undo state
    global int $canUndoMove;
    global string $undoMoveButton;

    // Can't change status if there isn't an active selection region
    if (!$selectionType) {
        confirmDialog -t "No Region Selected" -m "You must first create a selection region on canvas." -b "OK" -icn "warning";
        return;
    }

    $isMoveDistributionActive = ! $isMoveDistributionActive; // revert status
    if ($isMoveDistributionActive) {
        iconTextButton -e -l "Stop Moving Distribution" $moveButton;
        global string $selectionRegion[];
        global int $selectionType;
        // Get region properties
        float $width = 0;
        float $height = 0;
        float $bb[]; // bound box
        float $wp[]; // world position
        if ($selectionType == 1) {
            // PLANAR
            $width = `polyPlane -q -w $selectionRegion`;
            $height = `polyPlane -q -h $selectionRegion`;
            $bb = `exactWorldBoundingBox $selectionRegion`;
            $wp = `xform -q -ws -t $selectionRegion`;
        } else if ($selectionType == 2) {
            // RADIAL
            $width = `polyCylinder -q -r $selectionRegion[0]`;
            $bb = `exactWorldBoundingBox selectionRegion`;
            $wp = `xform -q -ws -t $selectionRegion`;
        }
        // Set current distribution on the C++ side (aka get the list of geoms inside the selection region)
        WorldPalette -sm true -st $selectionType -w $width -h $height -wp $wp[0] $wp[1] $wp[2] -mib $bb[0] $bb[1] $bb[2] -mab $bb[3] $bb[4] $bb[5];
    } else {
        iconTextButton -e -l "Start Moving Distribution" $moveButton;

        // Disable undo
        $canUndoMove = false;
        iconTextButton -e -en false $undoMoveButton;
    }
}

global proc changeResizeStatus()
{
    global int $selectionType;

    global int $isResizeDistributionActive;
    global string $resizeButton;

    // Undo state
    global int $canUndoResize;
    global string $undoResizeButton;

    // Can't change status if there isn't an active selection region
    if (!$selectionType) {
        confirmDialog -t "No Region Selected" -m "You must first create a selection region on canvas." -b "OK" -icn "warning";
        return;
    }

    $isResizeDistributionActive = ! $isResizeDistributionActive; // revert status
    if ($isResizeDistributionActive) {
        iconTextButton -e -l "Stop Resizing Distribution" $resizeButton;
        global string $selectionRegion[];
        global int $selectionType;
        // Get region properties
        float $width = 0;
        float $height = 0;
        float $bb[]; // bound box
        float $wp[]; // world position
        if ($selectionType == 1) {
            // PLANAR
            $width = `polyPlane -q -w $selectionRegion`;
            $height = `polyPlane -q -h $selectionRegion`;
            $bb = `exactWorldBoundingBox $selectionRegion`;
            $wp = `xform -q -ws -t $selectionRegion`;
        } else if ($selectionType == 2) {
            // RADIAL
            $width = `polyCylinder -q -r $selectionRegion[0]`;
            $bb = `exactWorldBoundingBox selectionRegion`;
            $wp = `xform -q -ws -t $selectionRegion`;
        }
        // Set current distribution on the C++ side (aka get the list of geoms inside the selection region)
        WorldPalette -sr true -st $selectionType -w $width -h $height -wp $wp[0] $wp[1] $wp[2] -mib $bb[0] $bb[1] $bb[2] -mab $bb[3] $bb[4] $bb[5];
    } else {
        iconTextButton -e -l "Start Resizing Distribution" $resizeButton;

        // Disable undo
        $canUndoResize = false;
        iconTextButton -e -en false $undoResizeButton;
    }
}

global proc moveAlongAxis(int $axis)
{
    global string $selectionRegion[];
    global int $selectionType;
    global int $isTerrainLoaded;

    // Selection region move sliders
    global string $moveXSlider;
    global string $moveZSlider;
    global int $isMoveDistributionActive;

    // Undo state
    global int $canUndoMove;
    global string $undoMoveButton;

    float $val = 0; // coordinate value
    float $dx = 0; // change in x-position
    float $dz = 0; // change in z-position
    if ($selectionType) {
        select -r $selectionRegion[0];
        if ($axis == 0) {
            // Add onto current X position
            $val = `floatSliderGrp -q -v $moveXSlider`;
            $dx = $val - (getAttr ($selectionRegion[0] + ".translateX"));
            move -x $val;
        } else if ($axis == 1) {
            // Add onto current Z position
            $val = `floatSliderGrp -q -v $moveZSlider`;
            $dz = $val - (getAttr ($selectionRegion[0] + ".translateZ"));
            move -z $val;
        }
        select -cl  ; // deselect

        // False: Move selection region
        // True: Move distribution within selection region
        if ($isMoveDistributionActive) {
            // Map region vertices to terrain height (if there is terrain)
            if ($isTerrainLoaded) {
                if ($axis == 0) {
                    WorldPalette -msr true -dx $dx;
                } else if ($axis == 1) {
                    WorldPalette -msr true -dz $dz;
                }
            } else {
                if ($axis == 0) {
                    WorldPalette -dx $dx;
                } else if ($axis == 1) {
                    WorldPalette -dz $dz;
                }
            }
            // Update undo state
            $canUndoMove = true;
            iconTextButton -e -en true $undoMoveButton;
        } else {
            // Map region vertices to terrain height (if there is terrain)
            if ($isTerrainLoaded) {
                WorldPalette -msr true;
            }
        }
    }
}

// Same function as moveAlongAxis except the region is moved with hotkeys instead
global proc moveAlongAxisHotkey(int $axis, int $value) 
{
    global string $selectionRegion[];
    global int $selectionType;
    global int $isTerrainLoaded;

    // Selection region move sliders
    global string $moveXSlider;
    global string $moveZSlider;
    global int $isMoveDistributionActive;

    // Undo state
    global int $canUndoMove;
    global string $undoMoveButton;

    float $val = 0; // coordinate value
    float $dx = 0; // change in x-position
    float $dz = 0; // change in z-position
    if ($selectionType) {
        select -r $selectionRegion[0];
        if ($axis == 0) {
            // Add onto current X position
            $val = (getAttr ($selectionRegion[0] + ".translateX"));
            $dx = $value;
            move -x ($val + $dx);
            // Update the slider value as well
            floatSliderGrp -e -v ($val + $dx) $moveXSlider;
        } else if ($axis == 1) {
            // Add onto current Z position
            $val = (getAttr ($selectionRegion[0] + ".translateZ"));
            $dz = $value;
            move -z ($val + $dz);
            // Update the slider value as well
            floatSliderGrp -e -v ($val + $dz) $moveZSlider;
        }
        select -cl  ; // deselect

        // False: Move selection region
        // True: Move distribution within selection region
        if ($isMoveDistributionActive) {
            // Map region vertices to terrain height (if there is terrain)
            if ($isTerrainLoaded) {
                if ($axis == 0) {
                    WorldPalette -msr true -dx $dx;
                } else if ($axis == 1) {
                    WorldPalette -msr true -dz $dz;
                }
            } else {
                if ($axis == 0) {
                    WorldPalette -dx $dx;
                } else if ($axis == 1) {
                    WorldPalette -dz $dz;
                }
            }
            // Update undo state
            $canUndoMove = true;
            iconTextButton -e -en true $undoMoveButton;
        } else {
            // Map region vertices to terrain height (if there is terrain)
            if ($isTerrainLoaded) {
                WorldPalette -msr true;
            }
        }
    }
}

global proc scaleRegion(int $axis)
{
    // Selection region state
    global string $selectionRegion[];
    global int $selectionType;
    global int $isMoveDistributionActive;

    // Selection region sliders
    global string $widthSlider;
    global string $heightSlider;
    global int $isResizeDistributionActive;

    // Undo state
    global int $canUndoResize;
    global string $undoResizeButton;

    // Terrain state
    global int $isTerrainLoaded;

    float $width = 0; // width of region
    float $height = 0; // height of region
    float $dw = 0; // change in width
    float $dh = 0; // change in height
    if ($selectionType) {
        if ($selectionType == 1) {
            select -r $selectionRegion[0];
            if ($axis == 0) {
                $width = `floatSliderGrp -q -v $widthSlider`;
                $dw = $width - (getAttr ($selectionRegion[1] + ".width"));
                // increase/decrease width
                setAttr ($selectionRegion[1] + ".width") ($width);
            } else if ($axis == 1) {
                $height = `floatSliderGrp -q -v $heightSlider`;
                $dh = $height - (getAttr ($selectionRegion[1] + ".height"));
                // increase/decrease height
                setAttr ($selectionRegion[1] + ".height") ($height);
            }
        } else if ($selectionType == 2) {
            select -r $selectionRegion[0];
            if ($axis == 0) {
                $width = `floatSliderGrp -q -v $widthSlider`;
                $dw = $width - (getAttr ($selectionRegion[1] + ".radius"));
                // increase/decrease radius
                setAttr ($selectionRegion[1] + ".radius") ($width);
            }
        }
        select -cl  ; // deselect

        // False: Resize selection region
        // True: Resize distribution within selection region
        if ($isResizeDistributionActive) {
            // Map region vertices to terrain height (if there is terrain)
            WorldPalette -msr $isTerrainLoaded -dw $dw -dh $dh;
            // Update undo state
            $canUndoResize = true;
            iconTextButton -e -en true $undoResizeButton;
        } else {
            // Map region vertices to terrain height (if there is terrain)
            WorldPalette -msr $isTerrainLoaded;
        }

        // Also update the selection region for moving the distribution
        // Get other region properties
        float $bb[] = `exactWorldBoundingBox $selectionRegion`;
        float $wp[] = `xform -q -ws -t $selectionRegion`;
        if ($isMoveDistributionActive) {
            WorldPalette -sm true -st $selectionType -w $width -h $height -wp $wp[0] $wp[1] $wp[2] -mib $bb[0] $bb[1] $bb[2] -mab $bb[3] $bb[4] $bb[5];
        }
    }
}

global proc clearSelection()
{
    global string $clearButton;
    global string $selectionRegion[];
    global int $selectionType;

    // Undo state
    global int $canUndoClear;
    global string $undoClearButton;

    // We must have an active selection region to be able to clear a distribution
    if ($selectionType) {
        // Get the current region properties
        float $width = 0;
        float $height = 0;
        float $boundBox[];
        float $worldPos[];
        if ($selectionType == 1) {
            // PLANAR
            $width = `polyPlane -q -w $selectionRegion`;
            $height = `polyPlane -q -h $selectionRegion`;
            $boundBox = `exactWorldBoundingBox $selectionRegion`;
            $worldPos = `xform -q -ws -t $selectionRegion`;
        } else if ($selectionType == 2) {
            // RADIAL
            $width = `polyCylinder -q -r $selectionRegion[0]`;
            $boundBox = `exactWorldBoundingBox selectionRegion`;
            $worldPos = `xform -q -ws -t $selectionRegion`;
        }
        // Clear the selection
        WorldPalette -csl true -st $selectionType -w $width -h $height -wp $worldPos[0] $worldPos[1] $worldPos[2] -mib $boundBox[0] $boundBox[1] $boundBox[2] -mab $boundBox[3] $boundBox[4] $boundBox[5];
        // Update undo state
        $canUndoClear = true;
        iconTextButton -e -en true $undoClearButton;
    } else {
        confirmDialog -t "No Region Selected" -m "You must first create a selection region on canvas." -b "OK" -icn "warning";
    }
}

global proc saveSelection()
{
    global string $selectionRegion[];
    global int $selectionType;
    if ($selectionType) {
        global string $palette[];
        global int $paletteOccupancy[];
        global int $numSlots;
        global int $freeIdx;
        
        // Create the image for this button
        string $ws=`workspace -q -fullName`;
        string $wsp=$ws + "/WorldPalette/images";
        sysFile -makeDir $wsp;
        string $imgFile = $wsp + "/palette" + $freeIdx + ".png";
        
        lookThru top; // look through the top camera
        focusOnCurrentSelection;
        setAttr ("SelectionLayer" + ".visibility") 0; // Don't show the GUI geometry in the screenshot
        refresh -cv -fe "png" -fn $imgFile; // take the screenshot
        setAttr ("SelectionLayer" + ".visibility") 1; // Put the GUI geometry back in
        lookThru persp; // go back to perspective view
        
        iconTextButton -e -i $imgFile $palette[$freeIdx]; // set slot image to screenshot
        iconTextButton -e -en true $palette[$freeIdx]; // make the button selectable
        
        if (!$paletteOccupancy[$freeIdx]) {
            // This slot is free - fill it
            $paletteOccupancy[$freeIdx] = 1;
        }
        
        // Send data to save the distribution
        float $width = 0;
        float $height = 0;
        float $boundBox[];
        float $worldPos[];
        if ($selectionType == 1) {
            // PLANAR
            $width = `polyPlane -q -w $selectionRegion`;
            $height = `polyPlane -q -h $selectionRegion`;
            $boundBox = `exactWorldBoundingBox $selectionRegion`;
            $worldPos = `xform -q -ws -t $selectionRegion`;
        } else if ($selectionType == 2) {
            // RADIAL
            $width = `polyCylinder -q -r $selectionRegion[0]`;
            $boundBox = `exactWorldBoundingBox selectionRegion`;
            $worldPos = `xform -q -ws -t $selectionRegion`;
        }
        WorldPalette -st $selectionType -w $width -h $height -wp $worldPos[0] $worldPos[1] $worldPos[2] -mib $boundBox[0] $boundBox[1] $boundBox[2] -mab $boundBox[3] $boundBox[4] $boundBox[5] -pi $freeIdx -ge true;
        // Update the free slot index
        $freeIdx = $freeIdx + 1;
        if ($freeIdx == $numSlots) {
            $freeIdx = 0; // set back to idx 0
        }
    } else {
        confirmDialog -t "No Region Selected" -m "You must first create a selection region on canvas." -b "OK" -icn "warning";
    }
}

global proc getDistributionFromPalette(int $index)
{
    global int $currentSlot;
    global string $palette[];
    
    // Update currently selected slot
    if ($currentSlot != -1) {
        iconTextButton -e -nbg true $palette[$currentSlot];
    }
    $currentSlot = $index;
    
    print ("Current selection: " + $currentSlot);
    iconTextButton -e -ebg true -bgc 0 0.75 1 $palette[$currentSlot];
    
    // This is where we will set the brush stroke to use the given distribution!
    WorldPalette -ge true -pi $currentSlot;
}

global proc updatePalette()
{
    global string $palette[];
    global int $paletteOccupancy[];
    global int $numSlots;
    global int $currentSlot;
    // Set the palette images accordingly
    // Free slot = default image (sphere.png) for now; Occupied = top view img
    
    // Get the image directory
    string $ws = `workspace -q -fullName`;
    string $wsp = $ws + "/WorldPalette/images";
    sysFile -makeDir $wsp; // creates the image directory (if one doesn't already exist)
    
    for ($i = 0; $i < $numSlots; $i++) {
        if ($paletteOccupancy[$i]) {
            // Make the button clickable
             iconTextButton -e -en true $palette[$i];
            // Set button image to top view image if slot is occupied
            string $imgFile = $wsp + "/palette" + $i + ".png";
            if ($currentSlot == $i) {
                // Mark this button as currently selected
                iconTextButton -e -i $imgFile -ebg true -bgc 0 0.75 1 $palette[$i];
            } else {
                iconTextButton -e -i $imgFile $palette[$i];
            }
        }
    }
}

global proc loadDefaultScene()
{
    // We want to stop the distribution move tool because we're basically changing all scene geometry information
    global int $isMoveDistributionActive;
    global string $moveButton;
    $isMoveDistributionActive = false;
    iconTextButton -e -l "Start Moving Distribution" $moveButton;

    global int $numTerrainLoads;
    global string $terrainName;
    global string $treeName;
    global string $rockName;
    global string $shrubName;
    global string $grassName;

    // Delete all geometry in the scene first
    string $objects[] = `listTransforms -geometry`;
    for ($geom in $objects) {
        if ($geom == "selectionRegion") {
            continue;
        }
        if ($geom == $treeName || $geom == $rockName || $geom == $shrubName || $geom == $grassName) {
            continue;
        }
        if ($geom == $terrainName) {
            continue;
        }
        delete $geom;
    }
    
    // Create a bunch of scene objects
    int $numPrims = 6;
    for ($i = 0; $i < $numPrims; $i++) {
        int $t = 3; // TREE
        float $rx = `rand -2 2`;
        float $rz = `rand -2 2`;
        addSceneGeometryAtLoc($t, $rx, 0, $rz);
    }

    int $numPrims2 = 6;
    for ($i = 0; $i < $numPrims2; $i++) {
        int $t = 2; // SHRUB
        float $rx = `rand -3 3`;
        float $rz = `rand -3 3`;
        addSceneGeometryAtLoc($t, $rx, 0, $rz);
    }

    int $numPrims3 = 20;
    for ($i = 0; $i < $numPrims3; $i++) {
        int $t = 1; // ROCK
        float $rx = `rand -4 4`;
        float $rz = `rand -4 4`;
        addSceneGeometryAtLoc($t, $rx, 0, $rz);
    }
    
    int $numPrims4 = 40;
    for ($i = 0; $i < $numPrims4; $i++) {
        int $t = 0; // GRASS
        float $rx = `rand -5 5`;
        float $rz = `rand -5 5`;
        addSceneGeometryAtLoc($t, $rx, 0, $rz);
    }
    select -cl  ; // deselect
}

global proc pasteDistribution()
{
    global int $currentSlot; // A slot must be selected first for pasting distributions
    global string $selectionRegion[];
    global int $selectionType; // There must be a selection region

    // Undo state
    global int $canUndoPaste;
    global string $undoPasteButton;

    if ($currentSlot != -1) {
        if ($selectionType) {
            float $width = 0;
            float $height = 0;
            float $boundBox[];
            float $worldPos[];
            if ($selectionType == 1) {
                // PLANAR
                $width = `polyPlane -q -w $selectionRegion`;
                $height = `polyPlane -q -h $selectionRegion`;
                $boundBox = `exactWorldBoundingBox $selectionRegion`;
                $worldPos = `xform -q -ws -t $selectionRegion`;
                WorldPalette -st 1 -w $width -h $height -wp $worldPos[0] $worldPos[1] $worldPos[2] -mib $boundBox[0] $boundBox[1] $boundBox[2] -mab $boundBox[3] $boundBox[4] $boundBox[5] -pi $currentSlot -ge false;
            } else if ($selectionType == 2) {
                // RADIAL
                $width = `polyCylinder -q -r $selectionRegion[0]`;
                $boundBox = `exactWorldBoundingBox selectionRegion`;
                $worldPos = `xform -q -ws -t $selectionRegion`;
                WorldPalette -st 2 -w $width -wp $worldPos[0] $worldPos[1] $worldPos[2] -mib $boundBox[0] $boundBox[1] $boundBox[2] -mab $boundBox[3] $boundBox[4] $boundBox[5] -pi $currentSlot -ge false;
            }
            // Update undo state
            $canUndoPaste = true;
            iconTextButton -e -en true $undoPasteButton;
        } else {
            confirmDialog -t "No Region Selected" -m "You must first create a selection region on canvas." -b "OK" -icn "warning";
        }
    } else {
        confirmDialog -t "No Slot Selected" -m "You must first select a distribution from the palette." -b "OK" -icn "warning";
    }
}

global proc changeBrushStatus()
{
    global int $currentSlot; // A slot must be selected first for using brush

    global string $brushDragContext;
    global int $isBrushActive;
    global string $brushButton;
    global string $brushWidthSlider;

    // Undo state
    global int $canUndoBrush;
    global int $canUndoErase;
    global string $undoBrushButton;
    global string $undoEraseButton;

    if ($currentSlot == -1) {
        confirmDialog -t "No Slot Selected" -m "You must first select a distribution from the palette." -b "OK" -icn "warning";
        return;
    }

    $isBrushActive = ! $isBrushActive; // revert status
    if ($isBrushActive) {
        iconTextButton -e -l "Stop Brush" $brushButton;
        // Set tool to brush
        setToolTo $brushDragContext;
        // Enable width slider
        floatSliderGrp -e -en true $brushWidthSlider;
    } else {
        iconTextButton -e -l "Use Brush" $brushButton;
        // Set tool back to selection
        setToolTo selectSuperContext;
        // Disable width slider
        floatSliderGrp -e -en false $brushWidthSlider;
        // Disable undo
        $canUndoBrush = false;
        iconTextButton -e -en false $undoBrushButton;
    }

    // Terminate eraser tool
    global int $isEraserActive;
    global string $eraserButton;
    $isEraserActive = false;
    iconTextButton -e -l "Use Eraser" $eraserButton;
    $canUndoErase = false;
    iconTextButton -e -en false $undoEraseButton;
}

global proc changeEraserStatus()
{
    global string $eraserDragContext;
    global int $isEraserActive;
    global string $eraserButton;
    global string $brushWidthSlider;

    // Undo state
    global int $canUndoBrush;
    global int $canUndoErase;
    global string $undoBrushButton;
    global string $undoEraseButton;

    $isEraserActive = ! $isEraserActive; // revert status
    if ($isEraserActive) {
        iconTextButton -e -l "Stop Eraser" $eraserButton;
        // Set tool to eraser
        setToolTo $eraserDragContext;
        // Enable width slider
        floatSliderGrp -e -en true $brushWidthSlider;
    } else {
        iconTextButton -e -l "Use Eraser" $eraserButton;
        // Set tool back to selection
        setToolTo selectSuperContext;
        // Disable width slider
        floatSliderGrp -e -en false $brushWidthSlider;
        // Disable undo
        $canUndoErase = false;
        iconTextButton -e -en false $undoEraseButton;
    }

    // Terminate brush tool
    global int $isBrushActive;
    global string $brushButton;
    $isBrushActive = false;
    iconTextButton -e -l "Use Brush" $brushButton;
    $canUndoBrush = false;
    iconTextButton -e -en false $undoBrushButton;
}

global proc changeBrushWidth()
{
    global float $brushWidth;
    global string $brushWidthSlider;

    // Get the slider value
    $brushWidth = `floatSliderGrp -q -v $brushWidthSlider`;
}

global proc brushInitialize()
{
    // This function handles brush usage for the case where the user activates brush by clicking on the Maya side menu
    global int $isBrushActive;
    global string $brushButton;
    global string $brushWidthSlider;

    // Undo state
    global int $canUndoErase;
    global string $undoEraseButton;

    $isBrushActive = true;
    iconTextButton -e -l "Stop Brush" $brushButton;

    // Terminate eraser tool
    global int $isEraserActive;
    global string $eraserButton;
    $isEraserActive = false;
    iconTextButton -e -l "Use Eraser" $eraserButton;
    $canUndoErase = false;
    iconTextButton -e -en false $undoEraseButton;

    // Enable brush width slider
    floatSliderGrp -e -en true $brushWidthSlider;
}

global proc eraserInitialize()
{
    global int $isEraserActive;
    global string $eraserButton;
    global string $brushWidthSlider;

    // Undo state
    global int $canUndoBrush;
    global string $undoBrushButton;

    $isEraserActive = true;
    iconTextButton -e -l "Stop Eraser" $eraserButton;

    // Terminate brush tool
    global int $isBrushActive;
    global string $brushButton;
    $isBrushActive = false;
    iconTextButton -e -l "Use Brush" $brushButton;
    $canUndoBrush = false;
    iconTextButton -e -en false $undoBrushButton;

    // Enable brush width slider
    floatSliderGrp -e -en true $brushWidthSlider;
}

global proc brushFinalize()
{
    // This function handles brush usage for the case where the user deactivates brush by clicking on the Maya side menu
    global int $isBrushActive;
    global string $brushButton;
    global string $brushWidthSlider;

    // Undo state
    global int $canUndoBrush;
    global string $undoBrushButton;

    $isBrushActive = false;
    iconTextButton -e -l "Use Brush" $brushButton;

    // Disable brush width slider
    floatSliderGrp -e -en false $brushWidthSlider;

    // Disable undo
    $canUndoBrush = false;
    iconTextButton -e -en false $undoBrushButton;
}

global proc eraserFinalize()
{
    // This function handles eraser usage for the case where the user deactivates eraser by clicking on the Maya side menu
    global int $isEraserActive;
    global string $eraserButton;
    global string $brushWidthSlider;

    // Undo state
    global int $canUndoErase;
    global string $undoEraseButton;

    $isEraserActive = false;
    iconTextButton -e -l "Use Eraser" $eraserButton;

    // Disable brush width slider
    floatSliderGrp -e -en false $brushWidthSlider;

    // Disable undo
    $canUndoErase = false;
    iconTextButton -e -en false $undoEraseButton;

}

global proc brushPress()
{
    float $pressPosition[] = `autoPlace -um`;
    WorldPalette -sb true -sbp $pressPosition[0] $pressPosition[2]; // send stroke position to C++
}

global proc brushDrag()
{
    global float $lastDragPosition[]; // last brush drag position
    global int $first; // is this the first brush stroke during drag?

    float $dragPosition[] = `autoPlace -um`;
    if ($first) {
        $first = false;
        WorldPalette -sb true -sbp $dragPosition[0] $dragPosition[2]; // send stroke position to C++
    } else {
        float $dx = $dragPosition[0] - $lastDragPosition[0];
        float $dz = $dragPosition[2] - $lastDragPosition[2];
        if ($dx > 0.01 || $dx < -0.01 || $dz > 0.01 || $dz < -0.01) {
            WorldPalette -sb true -sbp $dragPosition[0] $dragPosition[2]; // send stroke position to C++
        }
    }
    $lastDragPosition = `autoPlace -um`;
}

global proc brushRelease()
{
    // Undo state
    global int $canUndoBrush;
    global string $undoBrushButton;

    global int $first;
    global float $brushWidth;
    $first = true; // reset first brush stroke status
    WorldPalette -rb true -bw $brushWidth;

    // Enable undo
    $canUndoBrush = true;
    iconTextButton -e -en true $undoBrushButton;
}

global proc eraserRelease()
{
    // Undo state
    global int $canUndoErase;
    global string $undoEraseButton;

    global int $first;
    global float $brushWidth;
    $first = true; // reset first brush stroke status
    WorldPalette -re true -bw $brushWidth;

    // Enable undo
    $canUndoErase = true;
    iconTextButton -e -en true $undoEraseButton;
}

global proc addSceneGeom(int $type)
{
    global string $treeName;
    global string $rockName;
    global string $shrubName;
    global string $grassName;

    // This one generates the geometry at the origin
    switch($type) {
        case 0:
            // GRASS
            showHidden $grassName;
            select -r $grassName;
            duplicate -rr;
            hide $grassName;
            break;
        case 1:
            // ROCK
            showHidden $rockName;
            select -r $rockName;
            duplicate -rr;
            hide $rockName;
            break;
        case 2:
            // SHRUB
            showHidden $shrubName;
            select -r $shrubName;
            duplicate -rr;
            hide $shrubName;
            break;
        case 3:
            // TREE
            showHidden $treeName;
            select -r $treeName;
            duplicate -rr;
            hide $treeName;
            break;
        default:
            break;
    }
}

global proc addSceneGeometryAtLoc(int $type, float $wx, float $wy, float $wz)
{
    global int $isTerrainLoaded;
    // This one generates the geometry at given location
    addSceneGeom($type);
    move -x $wx -z $wz;
    // Update the y-position if there is terrain
    if ($isTerrainLoaded) {
        string $selected[] = `ls -sl`;
        WorldPalette -ugh $selected[0];
    }
}

global proc importSceneOBJs()
{
    // OBJ paths
    global string $treeOBJ;
    global string $rockOBJ;
    global string $shrubOBJ;
    global string $grassOBJ;
    
    // Import objects for tree and rock (UPDATE THIS FUNCTION IF MORE OBJECTS ARE SUPPORTED)
    file -import -type "OBJ"  -ignoreVersion -ra true -mergeNamespacesOnClash false -namespace "rock" -options "mo=1" -pr -importFrameRate true -importTimeRange "override" $rockOBJ; // ROCK
    file -import -type "OBJ"  -ignoreVersion -ra true -mergeNamespacesOnClash false -namespace "tree" -options "mo=1" -pr -importFrameRate true -importTimeRange "override" $treeOBJ; // TREE
    file -import -type "OBJ"  -ignoreVersion -ra true -mergeNamespacesOnClash false -namespace "shrub" -options "mo=1" -pr -importFrameRate true -importTimeRange "override" $shrubOBJ; // SHRUB
    file -import -type "OBJ"  -ignoreVersion -ra true -mergeNamespacesOnClash false -namespace "grass" -options "mo=1" -pr -importFrameRate true -importTimeRange "override" $grassOBJ; // GRASS

    // Hide these imported meshes
    hide tree:Tree;
    hide rock:Rock;
    hide shrub:Shrub;
    hide grass:Grass;
}

global proc uploadUserTree()
{
    // Current tree OBJ path
    global string $treeOBJ;
    global string $treeName;
    global int $numTreeLoads;

    // Have user select a new file
    string $opened = `fileDialog -dm "*.obj"`;
    if (size($opened) > 0) {
        // User selected a new tree OBJ file successfully - replace the default path
        $treeOBJ = $opened;
        // Replace the main hidden tree mesh to duplicate
        delete $treeName;
        $numTreeLoads += 1;
        file -import -type "OBJ"  -ignoreVersion -ra true -mergeNamespacesOnClash false -namespace "tree" -options "mo=1" -pr -importFrameRate true -importTimeRange "override" $treeOBJ; // TREE
        $treeName = ("tree" + $numTreeLoads + ":Tree");
        WorldPalette -setTreeOBJ $treeName;
        hide $treeName;
    }
}

global proc uploadUserRock()
{
    // Current rock OBJ path
    global string $rockOBJ;
    global string $rockName;
    global int $numRockLoads;

    // Have user select a new file
    string $opened = `fileDialog -dm "*.obj"`;
    if (size($opened) > 0) {
        // User selected a new rock OBJ file successfully - replace the default path
        $rockOBJ = $opened;
        // Replace the main hidden rock mesh to duplicate
        delete $rockName;
        $numRockLoads += 1;
        file -import -type "OBJ"  -ignoreVersion -ra true -mergeNamespacesOnClash false -namespace "rock" -options "mo=1" -pr -importFrameRate true -importTimeRange "override" $rockOBJ; // ROCK
        $rockName = ("rock" + $numRockLoads + ":Rock");
        WorldPalette -setRockOBJ $rockName;
        hide $rockName;
    }
}

global proc uploadUserShrub()
{
    // Current shrub OBJ path
    global string $shrubOBJ;
    global string $shrubName;
    global int $numShrubLoads;

    // Have user select a new file
    string $opened = `fileDialog -dm "*.obj"`;
    if (size($opened) > 0) {
        // User selected a new shrub OBJ file successfully - replace the default path
        $shrubOBJ = $opened;
        // Replace the main hidden shrub mesh to duplicate
        delete $shrubName;
        $numShrubLoads += 1;
        file -import -type "OBJ"  -ignoreVersion -ra true -mergeNamespacesOnClash false -namespace "shrub" -options "mo=1" -pr -importFrameRate true -importTimeRange "override" $shrubOBJ; // SHRUB
        $shrubName = ("shrub" + $numShrubLoads + ":Shrub");
        WorldPalette -setShrubOBJ $shrubName;
        hide $shrubName;
    }
}

global proc uploadUserGrass()
{
    // Current grass OBJ path
    global string $grassOBJ;
    global string $grassName;
    global int $numGrassLoads;

    // Have user select a new file
    string $opened = `fileDialog -dm "*.obj"`;
    if (size($opened) > 0) {
        // User selected a new grass OBJ file successfully - replace the default path
        $grassOBJ = $opened;
        // Replace the main hidden grass mesh to duplicate
        delete $grassName;
        $numGrassLoads += 1;
        file -import -type "OBJ"  -ignoreVersion -ra true -mergeNamespacesOnClash false -namespace "grass" -options "mo=1" -pr -importFrameRate true -importTimeRange "override" $grassOBJ; // GRASS
        $grassName = ("grass" + $numGrassLoads + ":Grass");
        WorldPalette -setGrassOBJ $grassName;
        hide $grassName;
    }
}

global proc loadTerrain()
{
    global int $isTerrainLoaded;
    global int $numTerrainLoads;
    global int $selectionType;
    if ($isTerrainLoaded) {
        // There is already a terrain - user must delete it first
        confirmDialog -t "Load Terrain" -m "There already exists a terrain. You must delete this existing terrain first." -b "OK" -icn "warning";
    } else {
        global string $terrainName;
        // Get the terrain directory - have user select the file
        string $opened = `fileDialog -dm "terrain*.obj"`;
        if (size($opened) > 0) {
            // Update terrain file    
            string $terName[];
            file -import -type "OBJ"  -ignoreVersion -ra true -mergeNamespacesOnClash false -namespace "terrain" -options "mo=1" -pr -importFrameRate true -importTimeRange "override" $opened;
            $numTerrainLoads += 1;
            // Get terrain name
            if ($numTerrainLoads) {
                select -r ("terrain" + $numTerrainLoads + ":*");
            } else {
                select -r "terrain:*";
            }
            $terName = `ls -sl -tr`;
            $terrainName = $terName[0];
            WorldPalette -tn $terrainName -tw 50 -th 50 -tsw 100 -tsh 100;
            $isTerrainLoaded = true;
            // Map selection region vertices to terrain height (if there is selection region)
            if ($selectionType) {
                WorldPalette -msr true;
            }
            select -cl;
        }
    }
}

global proc deleteTerrain()
{
    global int $isTerrainLoaded;
    global int $numTerrainLoads;
    global int $selectionType;
    if ($isTerrainLoaded) {
        global string $terrainName;
        select -r $terrainName;
        delete;
        $isTerrainLoaded = false;
        WorldPalette -ut true; // uninitialize terrain
        // Map selection region vertices to zero height (if there is selection region)
        if ($selectionType) {
            int $count[] = `polyEvaluate -v "selectionRegion"`;
            for ($idx = 0; $idx < $count[0]; $idx++) {
                select -r selectionRegion.vtx[$idx];
                move -y 0;
            }
            select -cl;
        }
    } else {
        // There isn't a terrain to delete
        confirmDialog -t "Delete Terrain" -m "There is no terrain." -b "OK" -icn "warning";
    }
}
global proc undoAction(int $actionId)
{
    // Undo buttons
    global string $undoMoveButton;
    global string $undoResizeButton;
    global string $undoClearButton;
    global string $undoPasteButton;
    global string $undoBrushButton;
    global string $undoEraseButton;

    // Undo states
    global int $canUndoMove;
    global int $canUndoResize;
    global int $canUndoClear;
    global int $canUndoPaste;
    global int $canUndoBrush;
    global int $canUndoErase;

    // Id mapping
    // 0 : move
    // 1 : resize
    // 2 : clear
    // 3 : paste
    // 4 : brush
    // 5 : erase
    switch($actionId) 
    {
        case 0:
            WorldPalette -umv $canUndoMove;
            $canUndoMove = false;
            iconTextButton -e -en false $undoMoveButton;
            break;
        case 1:
            WorldPalette -urs $canUndoResize;
            $canUndoResize = false;
            iconTextButton -e -en false $undoResizeButton;
            break;
        case 2:
            WorldPalette -ucr $canUndoClear;
            $canUndoClear = false;
            iconTextButton -e -en false $undoClearButton;
            break;
        case 3:
            WorldPalette -upt $canUndoPaste;
            $canUndoPaste = false;
            iconTextButton -e -en false $undoPasteButton;
            break;
        case 4:
            WorldPalette -ubr $canUndoBrush;
            $canUndoBrush = false;
            iconTextButton -e -en false $undoBrushButton;
            break;
        case 5:
            WorldPalette -uer $canUndoErase;
            $canUndoErase = false;
            iconTextButton -e -en false $undoEraseButton;
            break;
        default:
            break;
    }
}

global proc closeWindow()
{
    global int $isGUIOpen;
    $isGUIOpen = false;
}

global proc ShowGUI()
{
    global int $isGUIOpen;
    // Get the necessary global variables
    // Selection region radio buttons
    global string $noSelect;
    global string $planarSelect;
    global string $radialSelect;

    // Selection region attribute sliders
    global int $isMoveDistributionActive;
    global string $moveXSlider;
    global string $moveZSlider;
    global string $moveButton;
    global int $isResizeDistributionActive;
    global string $widthSlider;
    global string $heightSlider;
    global string $resizeButton;

    // Clear region
    global string $clearButton;

    // Brush/eraser attribute variables
    global int $isBrushActive;
    global int $isEraserActive;
    global string $brushButton;
    global string $eraserButton;
    global string $brushWidthSlider;

    // Undo buttons
    global string $undoMoveButton;
    global string $undoResizeButton;
    global string $undoClearButton;
    global string $undoPasteButton;
    global string $undoBrushButton;
    global string $undoEraseButton;

    // Undo states
    global int $canUndoMove;
    global int $canUndoResize;
    global int $canUndoClear;
    global int $canUndoPaste;
    global int $canUndoBrush;
    global int $canUndoErase;

    global string $modeCollection;
    global int $selectionType;
    // Priority Order
    global string $scrollPriority;
    // Palette
    global string $palette[];
    // Get the path for the object icons
    string $ws = `workspace -q -fullName`;
    string $iconDir = $ws + "/WorldPalette/icons/";
    // Create the GUI window
    string $window = `window -title "WorldPalette GUI" -s 1 -w 415 -cc closeWindow`;
        scrollLayout -w 430 -h 200 -vst 15 -cr true;
        columnLayout -adjustableColumn true;
            frameLayout -label "Selection" -collapsable true;
                frameLayout -label "Selection Mode";
                    rowColumnLayout -numberOfColumns 3 -columnWidth 1 125 -columnWidth 2 125 -columnWidth 3 125 -cs 1 5 -cs 2 10 -cs 3 10;
                        $modeCollection = `radioCollection`;
                        $noSelect = `radioButton -l "No Selection" -onc deleteCurrentSelectRegion`;
                        $planarSelect = `radioButton -l "Planar Selection" -onc makePlanarSelectRegion -ofc deleteCurrentSelectRegion`;
                        $radialSelect = `radioButton -l "Radial Selection" -onc makeRadialSelectRegion -ofc deleteCurrentSelectRegion`;
                    setParent ..;
                frameLayout -label "Move Selection";
                    rowColumnLayout -numberOfColumns 1 -co 1 "both" 5;
                        $moveXSlider = `floatSliderGrp -label "X Position" -en false -w 400 -field true -min -50 -max 50 -s 1 -cal 1 "center" -adj 1 -dc "moveAlongAxis(0)" -cc "moveAlongAxis(0)"`;
                        $moveZSlider = `floatSliderGrp -label "Z Position" -en false -w 400 -field true -min -50 -max 50 -s 1 -cal 1 "center" -adj 1 -dc "moveAlongAxis(1)" -cc "moveAlongAxis(1)"`;
                    setParent ..;
                frameLayout -label "Resize Selection";
                    rowColumnLayout -numberOfColumns 1 -columnWidth 1 400;
                        $widthSlider = `floatSliderGrp -label "Width" -en false -w 400 -field true -min 1 -max 10 -s 0.5 -cal 1 "center" -adj 1 -dc "scaleRegion(0)" -cc "scaleRegion(0)"`;
                        $heightSlider = `floatSliderGrp -label "Height" -en false -w 400 -field true -min 1 -max 10 -s 0.5 -cal 1 "center" -adj 1 -dc "scaleRegion(1)" -cc "scaleRegion(1)"`;
                    setParent ..;
                frameLayout -label "Editing Tools";
                    rowColumnLayout -numberOfColumns 2 -cw 1 200 -cw 2 200 -ro 1 "top" 5;
                        $moveButton = `iconTextButton -w 200 -h 35 -style "iconAndTextHorizontal" -i ($iconDir + "move.png") -label "Start Moving Distribution" -c changeMoveStatus`;
                        $undoMoveButton = `iconTextButton -w 200 -h 35 -en false -style "iconAndTextHorizontal" -i "undo.png" -label "Undo Move" -c "undoAction(0)"`;
                        $resizeButton = `iconTextButton -w 200 -h 35 -style "iconAndTextHorizontal" -i ($iconDir + "resize.png") -label "Start Resizing Distribution" -c changeResizeStatus`;
                        $undoResizeButton = `iconTextButton -w 200 -h 35 -en false -style "iconAndTextHorizontal" -i "undo.png" -label "Undo Resize" -c "undoAction(1)"`;
                        $clearButton = `iconTextButton -w 200 -h 35 -style "iconAndTextHorizontal" -i "Scrape.png" -label "Clear Distribution" -c clearSelection`;
                        $undoClearButton = `iconTextButton -w 200 -h 35 -en false -style "iconAndTextHorizontal" -i "undo.png" -label "Undo Clear" -c "undoAction(2)"`;
                    setParent ..;
                frameLayout -label "Other Options";
                    rowColumnLayout -numberOfColumns 2 -columnWidth 1 195 -columnWidth 2 195 -rs 1 5 -cs 1 5 -cs 2 5 -ro 1 "top" 5;
                    iconTextButton -h 35 -style "iconAndTextHorizontal" -i "CenterPivot.png" -label "Focus On Selection Region" -c focusOnCurrentSelection;
                    iconTextButton -h 35 -style "iconAndTextHorizontal" -i "save.png" -label "Save Selection to Palette" -c saveSelection;
                    setParent ..;
            setParent $window;
            frameLayout -label "Distribution" -collapsable true;
                frameLayout -label "Priority Order";
                    rowColumnLayout -numberOfColumns 2 -columnWidth 1 195 -columnWidth 2 195 -rs 1 5 -cs 1 5 -cs 2 10 -ro 1 "top" 5;
                        $scrollPriority = `textScrollList -numberOfRows 3 -dcc reorderPriority`;
                        button -l "Update Priority" -c updatePriority -h 25;
                    setParent ..;
                frameLayout -label "Palette";
                    rowColumnLayout -nc 5 -cw 1 50 -cw 2 50 -cw 3 50 -cw 4 50 -cw 5 50 -rs 1 5 -rs 2 5 -cs 1 5 -cs 2 5 -cs 3 5 -cs 4 5 -cs 5 5;
                    $palette[0] = `iconTextButton -st "iconOnly" -en false -i "sphere.png" -w 50 -h 50 -c "getDistributionFromPalette(0)"`;
                    $palette[1] = `iconTextButton -st "iconOnly" -en false -i "sphere.png" -w 50 -h 50 -c "getDistributionFromPalette(1)"`;
                    $palette[2] = `iconTextButton -st "iconOnly" -en false -i "sphere.png" -w 50 -h 50 -c "getDistributionFromPalette(2)"`;
                    $palette[3] = `iconTextButton -st "iconOnly" -en false -i "sphere.png" -w 50 -h 50 -c "getDistributionFromPalette(3)"`;
                    $palette[4] = `iconTextButton -st "iconOnly" -en false -i "sphere.png" -w 50 -h 50 -c "getDistributionFromPalette(4)"`;
                    $palette[5] = `iconTextButton -st "iconOnly" -en false -i "sphere.png" -w 50 -h 50 -c "getDistributionFromPalette(5)"`;
                    $palette[6] = `iconTextButton -st "iconOnly" -en false -i "sphere.png" -w 50 -h 50 -c "getDistributionFromPalette(6)"`;
                    $palette[7] = `iconTextButton -st "iconOnly" -en false -i "sphere.png" -w 50 -h 50 -c "getDistributionFromPalette(7)"`;
                    $palette[8] = `iconTextButton -st "iconOnly" -en false -i "sphere.png" -w 50 -h 50 -c "getDistributionFromPalette(8)"`;
                    $palette[9] = `iconTextButton -st "iconOnly" -en false -i "sphere.png" -w 50 -h 50 -c "getDistributionFromPalette(9)"`;
                    setParent ..;
                frameLayout -label "Paste Distribution";
                    rowColumnLayout -numberOfColumns 2 -columnWidth 1 195 -columnWidth 2 195 -rs 1 5 -cs 1 5 -cs 2 5 -ro 1 "top" 5;
                        iconTextButton -h 35 -style "iconAndTextHorizontal" -i "Imprint.png" -label "Paste Distribution" -c pasteDistribution;
                        $undoPasteButton = `iconTextButton -h 35 -en false -style "iconAndTextHorizontal" -i "undo.png" -label "Undo Paste" -c "undoAction(3)"`;
                    setParent ..;
            setParent $window;
            frameLayout -label "Brush" -collapsable true;
                frameLayout -label "Brush Properties";
                rowColumnLayout -numberOfColumns 1 -co 1 "both" 5 -ro 1 "top" 5;
                    $brushWidthSlider = `floatSliderGrp -label "Brush Width" -en false -w 400 -field true -v 0.5 -min 0.5 -max 10 -s 1 -cal 1 "center" -adj 1 -dc "changeBrushWidth" -cc "changeBrushWidth"`;
                setParent ..;
                frameLayout -label "Brush Tools";
                    rowColumnLayout -numberOfColumns 2 -columnWidth 1 200 -columnWidth 2 200 -ro 1 "top" 5;
                        $brushButton = `iconTextButton -w 400 -h 35 -style "iconAndTextHorizontal" -al "center" -i "art3dPaint.png" -label "Use Brush" -c changeBrushStatus`;
                        $undoBrushButton = `iconTextButton -w 400 -h 35 -en false -style "iconAndTextHorizontal" -al "center" -i "undo.png" -label "Undo Brush" -c "undoAction(4)"`;
                        $eraserButton = `iconTextButton -w 400 -h 35 -style "iconAndTextHorizontal" -al "center" -i "Erase.png" -label "Use Eraser" -c changeEraserStatus`;
                        $undoEraseButton = `iconTextButton -w 400 -h 35 -en false -style "iconAndTextHorizontal" -al "center" -i "undo.png" -label "Undo Eraser" -c "undoAction(5)"`;
                    setParent ..;
            setParent $window;        
            frameLayout -label "Scene" -collapsable true;
                frameLayout -label "Default";
                    rowColumnLayout -numberOfColumns 1 -columnWidth 1 400 -rs 1 5 -cs 1 5 -ro 1 "top" 5;
                        iconTextButton -h 35 -style "iconAndTextHorizontal" -i "Objects.png" -label "Load Default Scene" -c loadDefaultScene;
                    setParent ..;
                frameLayout -label "Customization";
                    rowColumnLayout -numberOfColumns 2 -columnWidth 1 195 -columnWidth 2 195 -rs 1 5 -cs 1 5 -cs 2 5;
                        iconTextButton -st "iconAndTextHorizontal" -l "Add Custom Tree" -i ($iconDir + "tree.png") -w 35 -h 35 -c "uploadUserTree";
                        iconTextButton -st "iconAndTextHorizontal" -l "Add Custom Rock" -i ($iconDir + "big_rock.png") -w 35 -h 35 -c "uploadUserRock";
                        iconTextButton -st "iconAndTextHorizontal" -l "Add Custom Shrub" -i ($iconDir + "shrub.png") -w 35 -h 35 -c "uploadUserShrub";
                        iconTextButton -st "iconAndTextHorizontal" -l "Add Custom Grass" -i ($iconDir + "grass.png") -w 35 -h 35 -c "uploadUserGrass";
                        iconTextButton -st "iconAndTextHorizontal" -l "Load Terrain" -i ($iconDir + "terrain.png") -w 35 -h 35 -c "loadTerrain";
                        iconTextButton -st "iconAndTextHorizontal" -l "Delete Terrain" -i ($iconDir + "terrain_delete.png") -w 35 -h 35 -c "deleteTerrain";
                    setParent ..;
            setParent $window;
          
    // Find which radio button must be set active
    global string $selectionRegion[];
    if ($selectionType) {
        // Enable the position sliders update their values
        floatSliderGrp -e -en true $moveXSlider;
        floatSliderGrp -e -en true $moveZSlider;
        float $xval = `getAttr ($selectionRegion[0] + ".translateX")`;
        float $zval = `getAttr ($selectionRegion[0] + ".translateZ")`;
        floatSliderGrp -e -v $xval $moveXSlider;
        floatSliderGrp -e -v $zval $moveZSlider;
        if ($selectionType == 1) {
            radioCollection -edit -select $planarSelect $modeCollection;
            // Enable the width slider and update its value
            floatSliderGrp -e -en true $widthSlider;
            float $width = `polyPlane -q -w $selectionRegion`;
            floatSliderGrp -e -v $width $widthSlider;
            // Enable the height slider and update its value
            floatSliderGrp -e -en true $heightSlider;
            float $height = `polyPlane -q -h $selectionRegion`;
            floatSliderGrp -e -v $height $heightSlider;
        } else if ($selectionType == 2) {
            radioCollection -edit -select $radialSelect $modeCollection;
            // Enable the width slider and update its value
            floatSliderGrp -e -en true $widthSlider;
            float $width = `polyCylinder -q -r $selectionRegion[0]`;
            floatSliderGrp -e -v $width $widthSlider;
        }
    } else {
        radioCollection -edit -select $noSelect $modeCollection;
        // Reset slider values
        floatSliderGrp -e -v 0 $moveXSlider;
        floatSliderGrp -e -v 0 $moveZSlider;
        floatSliderGrp -e -v 1 $widthSlider;
        floatSliderGrp -e -v 1 $heightSlider;
        // Stop moving the distribution immediately
        $isMoveDistributionActive = false;
        iconTextButton -e -l "Start Moving Distribution" $moveButton;
        // Stop resizing the distribution immediately
        $isResizeDistributionActive = false;
        iconTextButton -e -l "Start Resizing Distribution" $resizeButton;
    }
    if ($isBrushActive) {
        button -e -l "Stop Brush" $brushButton;
        floatSliderGrp -e -en true $brushWidthSlider;
    }
    if ($isEraserActive) {
        button -e -l "Stop Eraser" $eraserButton;
        floatSliderGrp -e -en true $brushWidthSlider;
    }
    // Enable undo buttons (if necessary)
    if ($canUndoMove) iconTextButton -e -en true $undoMoveButton;
    if ($canUndoResize) iconTextButton -e -en true $undoResizeButton;
    if ($canUndoClear) iconTextButton -e -en true $undoClearButton;
    if ($canUndoPaste) iconTextButton -e -en true $undoPasteButton;
    if ($canUndoBrush) iconTextButton -e -en true $undoBrushButton;
    if ($canUndoErase) iconTextButton -e -en true $undoEraseButton;
    // Append the items to priority order scroll in correct order
    fillPriority;
    // Update palette images
    updatePalette;
    
    showWindow;
    $isGUIOpen = true;    
}

global proc resetState()
{
    global int $isGUIOpen;
    global int $selectionType;
    global int $selectionExists;
    global string $noSelect;
    global string $modeCollection;
    global string $selectionLayer;
    global string $selectionMat;
    global int $isTerrainLoaded;

    // OBJ load counters
    global int $numTerrainLoads;
    global int $numTreeLoads;
    global int $numRockLoads;
    global int $numShrubLoads;
    global int $numGrassLoads;

    // Reset terrain
    $isTerrainLoaded = false;
    $numTerrainLoads = -1;
    // Reset scene OBJ counts
    $numTreeLoads = 0;
    $numRockLoads = 0;
    $numShrubLoads = 0;
    $numGrassLoads = 0;
    // Recreate the selection layer
    $selectionLayer = `createDisplayLayer -e -name "SelectionLayer"`;
    setAttr ($selectionLayer + ".displayType") 2; // We don't want the user to manipulate it
    // Recreate the selection material
    $selectionMat = `shadingNode -name "selection" -asShader lambert`;
    setAttr "selection.color" -type double3 0.2 0.8 0.8;
    setAttr "selection.transparency" -type double3 0.85 0.85 0.85;
    select -cl  ;
    // Delete the selection region
    $selectionType = 0;
    $selectionExists = false;
    if ($isGUIOpen) {
        // Set the radio button to "no selection" if the GUI window is open
        radioCollection -edit -select $noSelect $modeCollection;
    }
    // Reset the scene objects
    importSceneOBJs(); // re-import scene OBJs
}

global string $gMainWindow;
setParent $gMainWindow;

// Set Y as up axis
setUpAxis "y";

/*
    GUI Items
*/

// Selection region type radio buttons
global string $noSelect;
global string $planarSelect;
global string $radialSelect;
global string $modeCollection;

// Selection region sliders
global string $moveXSlider;
global string $moveZSlider;
global string $widthSlider;
global string $heightSlider;

// Move distribution
global string $moveButton;

// Resize distribution
global string $resizeButton;

// Clear button
global string $clearButton;

// Brush/Eraser
global string $brushButton;
global string $eraserButton;
global string $brushWidthSlider;

// Priority
global string $scrollPriority;

// Palette
global string $palette[];

// Undo buttons
global string $undoMoveButton;
global string $undoResizeButton;
global string $undoClearButton;
global string $undoPasteButton;
global string $undoBrushButton;
global string $undoEraseButton;

/*
    State Variables
*/

global int $isGUIOpen = false; // is the GUI window open?

// OBJ paths (may be overwritten by user input)
global string $treeOBJ;
global string $rockOBJ;
global string $shrubOBJ;
global string $grassOBJ;

// Scene object import counts
global int $numTreeLoads = 0;
global int $numRockLoads = 0;
global int $numShrubLoads = 0;
global int $numGrassLoads = 0;
global string $treeName;
global string $rockName;
global string $shrubName;
global string $grassName;

// Move Distribution
global int $isMoveDistributionActive = false;

// Resize Distribution
global int $isResizeDistributionActive = false;

// Terrain
global string $terrainName;
global int $isTerrainLoaded = false;
global int $numTerrainLoads = -1;

// Priority Order
global int $priorityOrder[] = { 3, 2, 1, 0 }; // 0 = GRASS; 1 = ROCK; 2 = SHRUB; 3 = TREE (UPDATE THIS IF MORE CATEGORIES ARE ADDED!)

// Distribution Palette
global int $numSlots = 10;
global int $freeIdx = 0; // Use the slot at this index for saving
global int $paletteOccupancy[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // We only support 10 slots for now (0 = free, 1 = occupied)
global int $currentSlot = -1; // currently selected slot/distribution

// Brush
global int $isBrushActive = false;
global float $brushWidth = 0.5;
global string $brushDragContext; // draggerContext
global float $lastDragPosition[]; // last brush drag position
global int $first; // is this the first brush stroke during drag?

// Eraser
global int $isEraserActive = false;
global string $eraserDragContext; // draggerContext

// Selection Shader
global string $selectionMat;

// Selection Region
global int $selectionExists = false;
global string $selectionRegion[];
global int $selectionType = 0;

// Undo states
global int $canUndoMove = false;
global int $canUndoResize = false;
global int $canUndoClear = false;
global int $canUndoPaste = false;
global int $canUndoBrush = false;
global int $canUndoErase = false;

// Create the selection display layer
global string $selectionLayer;
$selectionLayer = `createDisplayLayer -e -name "SelectionLayer"`;
setAttr ($selectionLayer + ".displayType") 2; // We don't want the user to manipulate it

// adds a new drop down menu
menu -l "World Palette"
-p MayaWindow
-to 1
-aob true
NewDropDownMenu;

// add an item to the drop down menu
menuItem -l "Show GUI"
-echoCommand true
-c ShowGUI
NewDropDownMenuItem1;

// Create selection shader
$selectionMat = `shadingNode -name "selection" -asShader lambert`;
setAttr "selection.color" -type double3 0.2 0.8 0.8;
setAttr "selection.transparency" -type double3 0.85 0.85 0.85;
select -cl  ;

// Set the brush dragger context
$brushDragContext = `draggerContext -i1 "art3dPaint.png" -inz "brushInitialize" -fnz "brushFinalize" -pc "brushPress" -dc  "brushDrag" -rc "brushRelease" -cursor "hand"`;

// Set the eraser dragger context
$eraserDragContext = `draggerContext -i1 "Erase.png" -inz "eraserInitialize" -fnz "eraserFinalize" -pc "brushPress" -dc  "brushDrag" -rc "eraserRelease" -cursor "hand"`;

// Reset the selection region and scene objects if a new scene is created
scriptJob -event "SceneOpened" resetState;

// Set up default OBJ paths
string $ws = `workspace -q -fullName`;
string $objDir = $ws + "/WorldPalette/objects/";
$treeOBJ = $objDir + "tree.obj";
$rockOBJ = $objDir + "big_rock.obj";
$shrubOBJ = $objDir + "shrub.obj";
$grassOBJ = $objDir + "grass.obj";

// Set up scene object names
$treeName = "tree:Tree";
$rockName = "rock:Rock";
$shrubName = "shrub:Shrub";
$grassName = "grass:Grass";

// Set the hotkeys
if (!`hotkeySet -ex WorldPaletteKeySet`) {
    hotkeySet -current WorldPaletteKeySet; // Set current hotkey set
}
nameCommand -annotation "Move Region Up" -command "moveAlongAxisHotkey(0,1)" moveSelRegionUp;
nameCommand -annotation "Move Region Down" -command "moveAlongAxisHotkey(0,-1)" moveSelRegionDown;
nameCommand -annotation "Move Left" -command " moveAlongAxisHotkey(1,1)" moveSelRegionLeft;
nameCommand -annotation "Move Right" -command "moveAlongAxisHotkey(1,-1)" moveSelRegionRight;
hotkey -k "w" -sht -name "moveSelRegionUp";
hotkey -k "s" -sht -name "moveSelRegionDown";
hotkey -k "a" -sht -name "moveSelRegionLeft";
hotkey -k "d" -sht -name "moveSelRegionRight";
// Import scene object meshes
importSceneOBJs();
